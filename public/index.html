<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Knowledge Factory</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mammoth@1.6.0/mammoth.browser.min.js"></script>
    <script>
        // Required setup for PDF.js
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.worker.min.js';
    </script>
    <style>
        /* Minimal styles for a clean interface */
        .input-field {
            @apply w-full px-4 py-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500/50 focus:border-blue-500 outline-none transition-all bg-white;
        }
        .btn {
            @apply px-6 py-3 text-white rounded-lg transition-colors duration-300 flex items-center justify-center gap-2 shadow-md hover:shadow-lg;
        }
        .btn-primary {
            @apply bg-blue-600 hover:bg-blue-700;
        }
        .btn-secondary {
            @apply bg-green-600 hover:bg-green-700;
        }
        .btn-danger {
            @apply bg-red-600 hover:bg-red-700;
        }
        .table-header {
            @apply px-6 py-3 text-left text-sm font-bold text-white uppercase tracking-wider bg-gray-800 sticky top-0;
        }
        .table-cell {
            @apply px-6 py-4 whitespace-normal break-words;
        }
        /* Make history table scrollable too */
        #result-table-container, #history-table-container {
            max-height: 500px;
            overflow-y: auto;
        }
        .keyword-tag {
            @apply inline-block bg-gray-200 rounded-full px-3 py-1 text-sm font-semibold text-gray-700 mr-2 mb-2;
        }

        /* Custom styles for navigation bar responsiveness */
        @media (max-width: 767px) {
            .navbar-collapse {
                display: none; /* Hidden by default on mobile */
                width: 100%;
            }
            .navbar-collapse.active {
                display: flex; /* Shown when active */
                flex-direction: column;
                align-items: center;
                margin-top: 1rem;
            }
            .navbar-nav {
                flex-direction: column;
                width: 100%;
            }
            .nav-item {
                margin: 0.5rem 0;
            }
            .navbar-cta-mobile {
                display: flex; /* Show CTA buttons on mobile when menu is active */
                flex-direction: column;
                width: 100%;
                gap: 0.5rem;
                margin-top: 1rem;
            }
        }
    </style>
</head>

<body class="bg-gray-50 font-sans min-h-screen flex flex-col">
    <nav class="bg-gray-800 p-4 shadow-md">
        <div class="container mx-auto flex justify-between items-center flex-wrap">
            <a href="#" class="text-white text-2xl font-bold hover:text-gray-300 transition-colors" data-page-id="qa-generation-section">Knowledge Factory</a>
            
            <button class="text-gray-300 hover:text-white md:hidden focus:outline-none" id="navbar-toggler">
                <i class="fas fa-bars text-xl"></i>
            </button>

            <div class="navbar-collapse w-full md:flex md:items-center md:w-auto" id="navbar-links">
                <ul class="navbar-nav flex flex-col md:flex-row md:space-x-8 mt-4 md:mt-0">
                    <li class="nav-item">
                        <a href="#" class="nav-link text-white hover:text-gray-300 transition-colors px-3 py-2 rounded-md bg-blue-600" data-page-id="qa-generation-section">Q&A Generation</a>
                    </li>
                    <li class="nav-item">
                        <a href="#qa-retrieval" class="nav-link text-gray-300 hover:text-white transition-colors px-3 py-2 rounded-md" data-page-id="qa-retrieval">Q&A Retrieval</a>
                    </li>
                    <li class="nav-item">
                        <a href="#history" class="nav-link text-gray-300 hover:text-white transition-colors px-3 py-2 rounded-md" data-page-id="history">History</a>
                    </li>
                    <li class="nav-item">
                        <a href="#settings" class="nav-link text-gray-300 hover:text-white transition-colors px-3 py-2 rounded-md" data-page-id="settings">Settings</a>
                    </li>
                </ul>
            </div>
        </div>
    </nav>

    <div class="container mx-auto px-4 py-8 max-w-4xl flex-grow">
        <div id="qa-generation-section" class="space-y-8">
            <h1 class="text-3xl font-bold mb-4 text-center">Q&A Generation</h1>
            <div class="bg-white rounded-xl shadow-md p-6 mb-8">
                <form id="qa-form" class="space-y-6">
                    <div class="grid grid-cols-1 md:grid-cols-3 gap-6">
                        <div>
                            <label for="file-upload" class="block text-sm font-medium text-gray-700">1. Upload Document</label>
                            <input type="file" id="file-upload" accept=".pdf,.docx,.mp4" class="input-field mt-1 file:mr-4 file:py-2 file:px-4 file:rounded-lg file:border-0 file:text-sm file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100">
                        </div>
                        <div>
                            <label for="document-language" class="block text-sm font-medium text-gray-700">2. Document Language</label>
                            <select id="document-language" class="input-field mt-1">
                                <option value="English">English</option>
                                <option value="Chinese Simplified">Chinese</option>
                            </select>
                        </div>
                        <div>
                            <label for="user-id" class="block text-sm font-medium text-gray-700">3. User ID</label>
                            <input type="text" id="user-id" class="input-field mt-1" placeholder="e.g., user-123">
                        </div>
                    </div>
                    <div>
                        <label for="kb-name" class="block text-sm font-medium text-gray-700">4. New Knowledge Base Name</label>
                        <input type="text" id="kb-name" class="input-field mt-1" placeholder="e.g., product-manual-v1">
                    </div>
                    <div>
                        <label for="generation-requirements" class="block text-sm font-medium text-gray-700">5. Generation Requirements (Optional)</label>
                        <textarea id="generation-requirements" class="input-field mt-1 min-h-[120px]" placeholder="Enter any specific instructions for Q&A generation..."></textarea>
                    </div>
                    <div class="flex flex-wrap gap-4 pt-4 border-t" id="action-buttons">
                        <button type="button" id="generate-button" class="btn btn-primary">
                            <i class="fa-solid fa-wand-magic-sparkles"></i> Generate Q&A
                        </button>
                        <button type="button" id="cancel-button" class="btn btn-danger hidden">
                            <i class="fa-solid fa-stop"></i> Force Stop
                        </button>
                        <!-- <button type="button" id="export-csv-button" class="btn btn-secondary">
                            <i class="fa-solid fa-file-csv"></i> Export as CSV
                        </button> -->
                        <button type="button" id="export-xlsx-button" class="btn btn-secondary">
                            <i class="fa-solid fa-file-excel"></i> Export as XLSX
                        </button>
                    </div>
                </form>
            </div>
            <div class="bg-white rounded-xl shadow-md p-6">
                <h2 class="text-xl font-bold mb-4">Results</h2>
                <div id="status" class="bg-gray-100 p-4 rounded-lg border mb-4 text-center">Waiting for action...</div>
                <div id="result-table-container">
                    <table id="result-table" class="min-w-full divide-y divide-gray-200">
                        <thead>
                            <tr>
                                <th class="table-header w-1/12">#</th>
                                <th class="table-header w-4/12">Question</th>
                                <th class="table-header w-4/12">Answer</th>
                                <th class="table-header w-3/12">Keywords</th>
                            </tr>
                        </thead>
                        <tbody id="result-table-body" class="bg-white divide-y divide-gray-200"></tbody>
                    </table>
                </div>
            </div>
        </div>

        <div id="qa-retrieval" class="bg-white rounded-xl shadow-md p-6 mt-8 hidden">
            <h1 class="text-3xl font-bold mb-4 text-center">Q&A Retrieval</h1>
            <p class="text-gray-600 mb-4">This section would allow users to query an existing knowledge base and retrieve answers.</p>
            <div class="space-y-4">
                <div>
                    <label for="query-input" class="block text-sm font-medium text-gray-700">Enter your question:</label>
                    <input type="text" id="query-input" class="input-field mt-1" placeholder="e.g., What are the product specifications?">
                </div>
                <div>
                    <label for="kb-select-retrieval" class="block text-sm font-medium text-gray-700">Select Knowledge Base:</label>
                    <select id="kb-select-retrieval" class="input-field mt-1">
                        <option value="">-- Select a KB --</option>
                    </select>
                </div>
                <div>
                    <label for="retrieval-user-id" class="block text-sm font-medium text-gray-700">User ID</label>
                    <input type="text" id="retrieval-user-id" class="input-field mt-1" placeholder="e.g., user-456">
                </div>
                <button type="button" id="query-button" class="btn btn-primary">
                    <i class="fa-solid fa-search"></i> Search Knowledge Base
                </button>
                <div class="bg-gray-100 p-4 rounded-lg mt-4" id="query-result-display">
                    <p class="text-gray-700">Query result will appear here.</p>
                </div>
            </div>
        </div>

        <div id="history" class="bg-white rounded-xl shadow-md p-6 mt-8 hidden">
            <h1 class="text-3xl font-bold mb-4 text-center">Generation History</h1>
            <p class="text-gray-600 mb-6 text-center">Review and load results from past runs saved in your browser.</p>
            <div id="history-table-container" class="overflow-x-auto">
                <table class="min-w-full divide-y divide-gray-200">
                    <thead>
                        <tr>
                            <th class="table-header">Knowledge Base Name</th>
                            <th class="table-header">Date Saved</th>
                            <th class="table-header">Q&A Pairs</th>
                            <th class="table-header">Actions</th>
                        </tr>
                    </thead>
                    <tbody id="history-table-body" class="bg-white divide-y divide-gray-200">
                        </tbody>
                </table>
            </div>
        </div>

        <div id="settings" class="bg-white rounded-xl shadow-md p-6 mt-8 hidden">
            <h1 class="text-3xl font-bold mb-4 text-center">Settings</h1>
            <p class="text-gray-600">Manage application settings and preferences here. This could include API key management, user profiles, etc.</p>
            <div class="mt-6">
                <label for="api-key-setting" class="block text-sm font-medium text-gray-700">API Key</label>
                <input type="password" id="api-key-setting" class="input-field mt-1" placeholder="****************">
                <button class="btn btn-secondary mt-3">Save Settings</button>
            </div>
        </div>

    </div>

    <footer class="bg-gray-800 text-white text-center p-4 mt-8">
        <p>&copy; 2025 Helport AI. All rights reserved.</p>
    </footer>

    <script>
        const HISTORY_STORAGE_KEY = 'kbf_history';
        const API_BASE_URL = ''; // The server is on the same origin
        let activeDatasetId = "";
        let activeDocumentIds = [];

        let isGenerationCancelled = false;
        let abortController = null;

        // TEST
        // loadDefaultData();

        // --- Event Listeners ---
        document.getElementById('generate-button').addEventListener('click', handleGeneration);
        //document.getElementById('export-csv-button').addEventListener('click', exportToCsv);
        document.getElementById('cancel-button').addEventListener('click', cancelGeneration);
        document.getElementById('export-xlsx-button').addEventListener('click', exportToXlsx);

        // Navbar Toggler for mobile
        document.getElementById('navbar-toggler').addEventListener('click', () => {
            const navbarLinks = document.getElementById('navbar-links');
            navbarLinks.classList.toggle('active');
        });


        // Cancel Function
        function cancelGeneration(){
            if (abortController){
                updateStatus('Cancelling process...', 'warning');
                isGenerationCancelled = true;
                abortController.abort();
            }
        }

        // --- Page Navigation (Simple Hash-based for this example) ---
        // Function to show/hide sections based on pageId
        function navigateToPage(pageId) {
            // Define all main content sections by their IDs
            const allSections = ['qa-generation-section', 'qa-retrieval', 'history', 'settings'];

            allSections.forEach(id => {
                const section = document.getElementById(id);
                if (section) {
                    section.classList.add('hidden'); // Hide all sections
                }
            });

            // Load knowledge bases when navigating to the retrieval page ---
            if (pageId === 'qa-retrieval') {
                loadKnowledgeBases();
            }

            // Show the target section
            const targetSection = document.getElementById(pageId);
            if (targetSection) {
                targetSection.classList.remove('hidden');
            }

            // Update active navigation link styling
            document.querySelectorAll('.nav-link').forEach(link => {
                link.classList.remove('bg-blue-600', 'text-white');
                link.classList.add('text-gray-300'); // Default inactive color
            });

            const activeLink = document.querySelector(`.nav-link[data-page-id="${pageId}"]`);
            if (activeLink) {
                activeLink.classList.add('bg-blue-600', 'text-white'); // Active color
                activeLink.classList.remove('text-gray-300');
            }

            // Also update the brand link if it's clicked to navigate to the "home" page
            const brandLink = document.querySelector('.navbar-brand');
            if (pageId === 'qa-generation-section' && brandLink) {
                brandLink.classList.add('text-white'); // Ensure brand is white
                brandLink.classList.remove('text-gray-300');
            } else if (brandLink) {
                // If on another page, make the brand link appear like other inactive links visually
                brandLink.classList.remove('text-white');
                brandLink.classList.add('text-gray-300');
            }
        }

        // Handle initial page load based on URL hash or default to Q&A Generation
        document.addEventListener("DOMContentLoaded", () => {
            const initialHash = window.location.hash.substring(1); // Remove '#' from hash
            const defaultPage = 'qa-generation-section';
            
            // Check if the hash corresponds to a known section, otherwise default
            if (initialHash && ['qa-generation-section', 'qa-retrieval', 'settings'].includes(initialHash)) {
                navigateToPage(initialHash);
            } else {
                navigateToPage(defaultPage); // Default to Q&A Generation
                window.history.replaceState(null, '', '#'); // Clean URL if no valid hash initially
            }

            // Attach click listeners for all navigation links
            document.querySelectorAll('.nav-link, .navbar-brand').forEach(link => {
                link.addEventListener('click', (event) => {
                    event.preventDefault(); // Prevent default link behavior
                    const pageId = link.dataset.pageId; // Get the custom data attribute
                    
                    if (pageId) {
                        // Update URL hash without full page reload
                        if (pageId === 'qa-generation-section') {
                            window.location.hash = ''; // Clear hash for the default page
                        } else {
                            window.location.hash = pageId;
                        }
                        navigateToPage(pageId);
                    }
                    
                    // Close mobile menu after clicking a link
                    const navbarLinks = document.getElementById('navbar-links');
                    if (navbarLinks.classList.contains('active')) {
                        navbarLinks.classList.remove('active');
                    }
                });
            });

            // Placeholder for the "query-button" from the Q&A Retrieval section
            // You'd connect this to your backend for actual retrieval logic
            const queryButton = document.getElementById("query-button");
            if (queryButton) {
                queryButton.addEventListener("click", handleQuery);
            }
        });

        // async function processAnswerFinding(datasetId, qaDatasetId, retryCount=0){
        //     updateStatus(`正在查找问题 "${question.substring(0, 60)}..." 的答案...`, 'loading');
        //     const question = document.getElementById('query-input').value;
        //     const datasetId = document.getElementById('kb-select-retrieval').value;
        //     const userId = document.getElementById('retrieval-user-id').value;
        //     const language = document.getElementById('document-language').value;
        //     const requestBody = {
        //         inputs: {
        //             doc_language: language,
        //             query: question,
        //             dataset_id: datasetId,
        //             qa_dataset_id: qaDatasetId,
        //             qa_document_id: qaDocumentId
        //         },
        //         response_mode: "streaming",
        //         user: userId
        //     };
        //     try {
        //         const response = await fetch(`${API_BASE_URL}/api/qa/findAnswer`, {
        //             method: "POST",
        //             headers:{
        //                 "Content-Type":"application/json"
        //             },
        //             body: JSON.stringify(requestBody)
        //         });
        //         if (!response.ok){
        //             throw new Error(`HTTP error! status: ${response.status}`);
        //         }


        //     } catch(error) {
        //         console.error('Failed answer retrieval', error);
        //         if (error.message.includes("Document is not completed") && retryCount < 5) {
        //             updateStatus(`检测到问答知识库初始化未完成，请稍后，15秒后开始第${retryCount + 1}次重试...`, 'warning');
        //             return new Promise(resolve => {
        //                 setTimeout(() => {
        //                     resolve(processAnswerFinding(
        //                         question,
        //                         language,
        //                         datasetId,
        //                         qaDatasetId,
        //                         qaDocumentId,
        //                         token,
        //                         clientId,
        //                         retryCount + 1
        //                     ));
        //                 }, 15000); // 15秒间隔
        //             });
        //         } else {
        //             updateStatus(`Failed to find answer: ${error.message}`, 'error');
        //             throw error;
        //         }
        //     }
        // }

        // Placeholder function for handleQuery (for the new Retrieval section)
        async function handleQuery() {
            const queryInput = document.getElementById('query-input').value;
            const kbSelect = document.getElementById('kb-select-retrieval').value;
            const queryResultDisplay = document.getElementById('query-result-display');
            const userId = document.getElementById('retrieval-user-id').value;
            const language = document.getElementById('document-language').value; // Get language from the form

            if (!queryInput || !kbSelect || !userId) {
                queryResultDisplay.innerHTML = '<p class="text-red-600">Please provide a User ID, select a knowledge base, and enter a query.</p>';
                return;
            }

            queryResultDisplay.innerHTML = '<p class="text-blue-600 animate-pulse">Searching...</p>';

            try {
                // Step 1: Create a temporary Q&A knowledge base to store the results.
                const shortId = await getShortIdFromBackend(kbSelect);

                const tempKbName = `temp-kb-${shortId}`;
                updateStatus('Creating temporary Q&A session...', 'loading');
                const createKbResponse = await fetch(`${API_BASE_URL}/api/qa/create_qa_knowledge`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        inputs: {
                            qa_knowledge_name: tempKbName,
                            doc_language: language,
                            clear_history: "否"
                        },
                        response_mode: "blocking",
                        user: userId
                    })
                });
                if (!createKbResponse.ok) throw new Error('Could not create a temporary Q&A session.');
                const createKbData = await createKbResponse.json();
                const { qa_dataset_id, qa_document_id } = createKbData.data.outputs;

                // Step 2: Call the findAnswer workflow with ALL required inputs.
                updateStatus('Retrieving answer from knowledge base...', 'loading');
                const findAnswerBody = {
                    inputs: {
                        query: queryInput,
                        dataset_id: kbSelect, // The source KB selected by the user
                        doc_language: language,
                        qa_dataset_id: qa_dataset_id, // The temporary KB ID
                        qa_document_id: qa_document_id // The temporary document ID
                    },
                    response_mode: "blocking",
                    user: userId
                };
                
                const response = await fetch(`${API_BASE_URL}/api/qa/findAnswer`, { 
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(findAnswerBody)
                });
                
                const data = await response.json();

                if (!response.ok) {
                    throw new Error(data.error || 'Failed to retrieve answer.');
                }

                // The answer is now inside the 'result' of the 'chunks插入文档' node.
                const finalResult = data.data?.outputs?.result?.[0];

                if (finalResult && finalResult.status === 'success') {
                    const answerContent = finalResult.response?.data?.[0]?.answer || "Answer found, but content is empty.";
                    queryResultDisplay.innerHTML = `<p class="font-semibold">Answer:</p><p>${answerContent}</p>`;
                    updateStatus('Answer retrieved successfully!', 'success');
                } else {
                    queryResultDisplay.innerHTML = `<p class="text-gray-700">No relevant answer found. (Status: ${finalResult?.status}, Message: ${finalResult?.message})</p>`;
                    updateStatus('Completed, but no answer was found.', 'info');

                }

            } catch (error) {
                queryResultDisplay.innerHTML = `<p class="text-red-600">Error: ${error.message}</p>`;
                updateStatus(`Error: ${error.message}`, 'error');
                console.error('Retrieval failed:', error);
            } finally {
                if (qa_dataset_id) {
                    updateStatus('Cleaning up temporary session...', 'loading');
                    try {
                        await fetch(`${API_BASE_URL}/api/datasets/${qa_dataset_id}`, {
                            method: 'DELETE',
                            headers: { 'Content-Type': 'application/json' }
                        });
                        console.log(`Temporary knowledge base ${qa_dataset_id} deleted successfully.`);
                        updateStatus('Cleanup complete.', 'success');
                    } catch (cleanupError) {
                        console.error('Failed to delete temporary knowledge base:', cleanupError);
                        updateStatus('Failed to clean up temporary session.', 'error');
                    }
                }
            }
        }
        // still working on it
        // async function waitForDocumentCompletion(datasetId, batch) {
        //     let isCompleted = false;
        //     let attempts = 0;
        //     const maxAttempts = 10;
        //     const delayMs = 2000; // Poll every 2 seconds

        //     while (!isCompleted && attempts < maxAttempts) {
        //         attempts++;
        //         updateStatus(`Checking document status (${attempts}/${maxAttempts})...`, 'loading');
        //         try {
        //             const response = await fetch(`${API_BASE_URL}/api/document_status`, {
        //                 method: 'GET',
        //                 headers: { 'Content-Type': 'application/json' },
        //                 body: JSON.stringify({ datasetId, batch })
        //             });
        //             const data = await response.json();

        //             // Adjust this condition based on your backend's actual status response
        //             if (response.ok && data.status === 'completed') { 
        //                 isCompleted = true;
        //             } else {
        //                 console.log(`Document ${documentId} not yet completed. Retrying...`);
        //                 await new Promise(resolve => setTimeout(resolve, delayMs));
        //             }
        //         } catch (error) {
        //             console.error('Error checking document status:', error);
        //             await new Promise(resolve => setTimeout(resolve, delayMs));
        //         }
        //     }

        //     if (!isCompleted) {
        //         throw new Error(`Document ${documentId} did not complete in time.`);
        //     }
        //     updateStatus('Document is ready!', 'info');
        // }

        /**
         * Main function to handle the Q&A generation process.
         */
        async function handleGeneration() {
            // 1. Get and validate inputs
            isGenerationCancelled = false;
            const fileInput = document.getElementById('file-upload');
            const file = fileInput.files[0];
            const userId = document.getElementById('user-id').value;
            const kbName = document.getElementById('kb-name').value;
            const language = document.getElementById('document-language').value;
            const requirements = document.getElementById('generation-requirements').value;
            const resultTableBody = document.getElementById('result-table-body');
            document.getElementById('cancel-button').classList.remove('hidden');
            document.getElementById('generate-button').disabled = true;
            
            if (!file || !userId || !kbName) {
                updateStatus('Please fill all fields: Upload Document, User ID, and Knowledge Base Name.', 'error');
                return;
            }

            // 2. Reset UI
            resultTableBody.innerHTML = '';
            updateStatus('Starting process...', 'loading');

            try {
                // 3. Parse file into text chunks
                updateStatus('Parsing file...', 'loading');
                const chunks = await parseFileIntoChunks(file);
                if (!chunks || chunks.length === 0) {
                    throw new Error('Could not extract any text from the file.');
                }
                updateStatus(`File parsed into ${chunks.length} text chunks.`, 'info');
                
                // 4. Create the empty Q&A knowledge base
                updateStatus('Creating Q&A knowledge base...', 'loading');
                const { qa_dataset_id, qa_document_id } = await createQAKnowledgeBase(kbName, language, userId);
                activeDatasetId = qa_dataset_id; // Store for potential future use (e.g., in retrieval)
                activeDocumentIds.push(qa_document_id); // Store all document IDs
                updateStatus('Knowledge base created. Starting Q&A generation...', 'info');
                //waitForDocumentCompletion(activeDatasetId, userId);
                // 5. Process each chunk to generate Q&A
                let globalRowIndex = 1;
                for (const chunk of chunks) {
                    if (isGenerationCancelled){
                        updateStatus('Process stopped by user.', 'info');
                        break;
                    }
                    updateStatus(`Processing number ${globalRowIndex} Q&A`, 'loading');
                    const qaPairs = await generateQaFromChunk(chunk, language, qa_dataset_id, qa_document_id, userId, requirements);
                    
                    if (isGenerationCancelled) break;

                    qaPairs.forEach(pair => {
                        const row = resultTableBody.insertRow();
                        const keywordsHtml = (pair.keywords || [])
                            .map(kw => `<span class="keyword-tag">${kw}</span>`)
                            .join(', ');
                        row.innerHTML = `
                            <td class="table-cell text-center">${globalRowIndex++}</td>
                            <td class="table-cell">${pair.content || 'N/A'}</td>
                            <td class="table-cell">${pair.answer || 'N/A'}</td>
                            <td class="table-cell">${keywordsHtml || 'N/A'}</td>
                        `;
                    });
                    // Auto-scroll to the bottom of the table
                    document.getElementById('result-table-container').scrollTop = document.getElementById('result-table-container').scrollHeight;
                }

                updateStatus(`Generation complete! ${resultTableBody.rows.length} Q&A pairs created.`, 'success');

            } catch (error) {
                updateStatus(`An error occurred: ${error.message}`, 'error');
                console.error('Generation process failed:', error);
            } finally {
                document.getElementById('generate-button').disabled = false;
                document.getElementById('cancel-button').classList.add('hidden');
                isGenerationCancelled = false;
                abortController = null;
            }
        }

        /**
         * A utility to split a large block of text into smaller chunks.
         * This helps ensure each chunk fits within the context window of the AI model.
         * @param {string} text The full text to be chunked.
         * @param {number} chunkSize The approximate size of each chunk in characters.
         */
        function chunkText(text, chunkSize = 2000) {
            const chunks = [];
            // Split by paragraph-like structures first to maintain context
            const paragraphs = text.split(/\n\s*\n/); 
            let currentChunk = '';

            for (const para of paragraphs) {
                // If adding the next paragraph exceeds the chunk size, push the current chunk and start a new one.
                if (currentChunk.length + para.length + 2 > chunkSize && currentChunk.length > 0) {
                    chunks.push(currentChunk.trim());
                    currentChunk = '';
                }
                currentChunk += para + '\n\n';
            }

            // Add the last remaining chunk
            if (currentChunk.trim()) {
                chunks.push(currentChunk.trim());
            }

            return chunks;
        }


        /**
         * Parses the uploaded file (PDF or DOCX) into an array of text chunks.
         */
        async function parseFileIntoChunks(file) {
            const fileExtension = file.name.split('.').pop().toLowerCase();
            if (fileExtension === 'pdf') {
                return await parsePdf(file);
            } else if (fileExtension === 'docx') {
                return await parseDocx(file);
            } else if (fileExtension === 'mp4') {
                return await parseMp4(file);
            } else {
                throw new Error('Unsupported file type. Please upload a PDF or DOCX file.');
            }
        }

        async function parsePdf(file) {
            const loadingTask = pdfjsLib.getDocument(URL.createObjectURL(file));
            const pdf = await loadingTask.promise;
            const chunks = [];
            for (let i = 1; i <= pdf.numPages; i++) {
                const page = await pdf.getPage(i);
                const textContent = await page.getTextContent();
                const pageText = textContent.items.map(item => item.str).join(' ');
                if (pageText.trim()) {
                    chunks.push(pageText);
                }
            }
            return chunks;
        }

        async function parseDocx(file) {
            const arrayBuffer = await file.arrayBuffer();
            const result = await mammoth.extractRawText({ arrayBuffer });
            // Split the text into manageable chunks (e.g., by paragraph or character count)
            return result.value.split(/\n\s*\n/).filter(p => p.trim());
        }

        async function parseMp4(file) {
            updateStatus('Uploading and processing video... This may take several minutes.', 'loading');
            const formData = new FormData();
            formData.append('video', file);
            formData.append('user', document.getElementById('user-id').value);

            const response = await fetch(`${API_BASE_URL}/api/video/process`, {
                method: 'POST',
                body: formData
            });

            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(`Failed to process video: ${errorData.error}`);
            }

            const result = await response.json();
            
            updateStatus('Video processing complete. Chunking text...', 'loading');
            
            // **CRITICAL CHANGE**: Chunk the returned text on the frontend
            return chunkText(result.full_text);
        }

        /**
         * Creates an empty Q&A knowledge base via the backend API.
         */
        async function createQAKnowledgeBase(kbName, language, userId) {
            const response = await fetch(`${API_BASE_URL}/api/qa/create_qa_knowledge`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    inputs: {
                        qa_knowledge_name: kbName,
                        doc_language: language,
                        clear_history: "否"
                    },
                    response_mode: "blocking",
                    user: userId
                })
            });
            const data = await response.json();
            if (!response.ok) throw new Error(data.error || 'Failed to create QA knowledge base.');
            return data.data.outputs;
        }

        /**
         * Sends a text chunk to the backend to generate Q&A pairs.
         */
        async function generateQaFromChunk(chunk, language, qaDatasetId, qaDocumentId, userId, requirements) {
            abortController = new AbortController();
            const response = await fetch(`${API_BASE_URL}/api/qa/generate`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    inputs: {
                        chunk: chunk,
                        doc_language: language,
                        qa_dataset_id: qaDatasetId,
                        qa_document_id: qaDocumentId,
                        generation_requirements: requirements,
                        excluded_questions: "" // This can be enhanced later if needed
                    },
                    response_mode: "blocking",
                    user: userId
                })
            });
            const data = await response.json();
            if (!response.ok) throw new Error(data.error || 'Failed to generate Q&A for a chunk.');
            return data.data?.outputs?.result?.[0]?.response?.data || [];
        }

        // Function to load knowledge bases into the dropdown
        async function loadKnowledgeBases() {
            const select = document.getElementById('kb-select-retrieval');
            select.innerHTML = '<option>Loading...</option>';
            try {
                updateStatus('Loading knowledge bases...', 'info');
                const response = await fetch('/api/datasets');
                if (!response.ok) throw new Error('Failed to fetch API.');
                
                const data = await response.json();
                // --- CORRECTED LINE ---
                const datasets = data.data.data || []; // Access the nested data array

                if(datasets.length > 0) {
                    select.innerHTML = datasets.map(d => `<option value="${d.id}">${d.name}</option>`).join('');
                    updateStatus('Knowledge bases loaded. Please select one.', 'success');
                } else {
                    select.innerHTML = '<option value="">No knowledge bases found</option>';
                    updateStatus('No knowledge bases were found on the platform.', 'info');
                }
            } catch (error) {
                updateStatus(`Error: ${error.message}`, 'error');
                select.innerHTML = `<option value="">Error loading KBs</option>`;
            }
        }

        /**
         * Exports the content of the results table to a CSV file.
         */
        function exportToCsv() {
            const table = document.getElementById("result-table");
            if (table.rows.length <= 1) {
                updateStatus('No data to export.', 'warning');
                return;
            }

            let csvContent = "data:text/csv;charset=utf-8,";
            csvContent += "Index,Question,Answer,Keywords\n"; // Header row

            for (let i = 1; i < table.rows.length; i++) {
                const cells = table.rows[i].cells;
                const index = cells[0].textContent;
                const question = `"${cells[1].textContent.replace(/"/g, '""')}"`;
                const answer = `"${cells[2].textContent.replace(/"/g, '""')}"`;
                
                // Extract keywords from the span tags
                const keywordSpans = cells[3].querySelectorAll('.keyword-tag');
                const keywords = Array.from(keywordSpans).map(span => span.textContent).join(', ');
                
                const rowData = [index, question, answer, `"${keywords}"`].join(',');
                csvContent += rowData + "\r\n";
            }

            const encodedUri = encodeURI(csvContent);
            const link = document.createElement("a");
            link.setAttribute("href", encodedUri);
            link.setAttribute("download", "qa_results.csv");
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        function exportToXlsx() {
            const resultTableBody = document.getElementById('result-table-body');
            if (resultTableBody.rows.length === 0) {
                updateStatus('No data to export.', 'warning');
                return;
            }

            updateStatus('Generating XLSX file...', 'loading');

            const header = [
                "分类(选填)", 
                "问题(必填)", 
                "回答", 
                "相似问题(选填-多个用##分隔)", 
                "反例问题(选填-多个用##分隔)", 
                "是否全部回复(选填-默认FALSE)", 
                "是否停用(选填-默认FALSE)", 
                "置信度阈值(选填-默认0)"
            ];

            const dataForExport = Array.from(resultTableBody.rows).map(row => {
                const cells = row.cells;
                const question = cells[1].textContent;
                const answer = cells[2].textContent;

                return {
                    "分类(选填)": "",
                    "问题(必填)": question,
                    "回答": answer,
                    "相似问题(选填-多个用##分隔)": "",
                    "反例问题(选填-多个用##分隔)": "",
                    "是否全部回复(选填-默认FALSE)": "FALSE",
                    "是否停用(选填-默认FALSE)": "FALSE",
                    "置信度阈值(选填-默认0)": 0.7
                };
            });

            const workbook = XLSX.utils.book_new();
            const worksheet = XLSX.utils.json_to_sheet(dataForExport, { header: header });

            const headerStyle = {
                font: { bold: true, color: { rgb: "FFFFFF" } },
                fill: { fgColor: { rgb: "4F81BD" } },
                alignment: { horizontal: "center", vertical: "center" }
            }
            header.forEach((_, index) => {
                const cellAddress = XLSX.utils.encode_cell({ c: index, r:0 });
                if (worksheet[cellAddress]){
                    worksheet[cellAddress].s = headerStyle;
                }
            });
            worksheet['!cols'] = [
                { wch: 15 }, // 分类
                { wch: 50 }, // 问题
                { wch: 70 }, // 回答
                { wch: 30 }, // 相似问题
                { wch: 30 }, // 反例问题
                { wch: 20 }, // 是否全部回复
                { wch: 20 }, // 是否停用
                { wch: 20 }  // 置信度阈值
            ];

            XLSX.utils.book_append_sheet(workbook, worksheet, 'Q&A Results');

            const kbName = document.getElementById('kb-name').value || 'knowledge_factory';
            const fileName = `${kbName}_export.xlsx`;
            XLSX.writeFile(workbook, fileName);

            updateStatus('XLSX file generated successfully!', 'success');
        }

        /**
         * Updates the status message display.
         */
        function updateStatus(message, type = 'info') {
            const statusDiv = document.getElementById("status");
            let colorClass = 'bg-gray-100';
            if (type === 'success') colorClass = 'bg-green-100 text-green-800';
            if (type === 'error') colorClass = 'bg-red-100 text-red-800';
            if (type === 'loading') colorClass = 'bg-blue-100 text-blue-800 animate-pulse';
            
            statusDiv.className = `p-4 rounded-lg border text-center ${colorClass}`;
            statusDiv.textContent = message;
        }

        // This async function calls your new backend endpoint
        async function getShortIdFromBackend(uuid) {
            try {
                const response = await fetch('/api/generate-short-id', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ longId: uuid })
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error || 'Network response was not ok');
                }

                const data = await response.json();
                return data.shortId;

            } catch (error) {
                console.error('There was a problem fetching the short ID:', error);
                return null;
            }
        }

        function isTableOfContents(text) {
            // 目录检测规则，可以根据实际情况调整
            const tableOfContentsKeywords = [
                "目录", "Contents", "目 录", "目　录", "索引",
                "第", "章", "节", ". . . .", "....", "Index\r\n"
            ];
            return tableOfContentsKeywords.some(keyword => text.includes(keyword));
        }

        function loadDefaultData() {
            const resultTableBody = document.getElementById('result-table-body');
            resultTableBody.innerHTML = ''; // Clear any existing content
            const defaultQaPairs = [
                {
                    question: "What is the primary goal of the Knowledge Factory application?",
                    answer: "The primary goal is to process documents and videos to automatically generate structured Question & Answer pairs, which can then be used as a knowledge base.",
                    keywords: ["goal", "application", "knowledge base"]
                },
                {
                    question: "What file types are supported for upload?",
                    answer: "The application supports uploading PDF (.pdf), Word Documents (.docx), and video files (.mp4).",
                    keywords: ["file types", "upload", "pdf", "docx", "mp4"]
                },
                {
                    question: "How can a user save their generated results for later use?",
                    answer: "Users can save their results either by exporting to a styled XLSX file or by using the 'Save to History' feature, which stores the session in the browser's LocalStorage.",
                    keywords: ["save", "export", "history", "xlsx"]
                }
            ];
            let globalRowIndex = 1;
            defaultQaPairs.forEach(pair => {
                const row = resultTableBody.insertRow();
                const keywordsHtml = (pair.keywords || []).map(kw => `<span class="keyword-tag">${kw}</span>`).join(' ');
                
                row.innerHTML = `
                    <td class="table-cell text-center">${globalRowIndex++}</td>
                    <td class="table-cell">${pair.question}</td>
                    <td class="table-cell">${pair.answer}</td>
                    <td class="table-cell">${keywordsHtml}</td>
                `;
            });
            updateStatus('Showing default example data. Ready to generate.', 'info');
        }
        async function parseFileToText(file){
            const fileExtension = file.name.split('.').pop().toLowerCase();
            if (fileExtension === 'pdf'){
                return await parsePdfToText(file);
            } else if (fileExtension === 'docx'){
                return await parseDocxToText(file);
            } else if (fileExtension === 'mp4'){
                return await parseMp4(file);
            } else {
                throw new Error('Unsupported file type.');
            }
        }
        async function parsePdfToText(file) {
            const loadingTask = pdfjsLib.getDocument(URL.createObjectURL(file));
            const pdf = await loadingTask.promise;
            let fullText = '';
            for (let i = 1; i <= pdf.numPages; i++) {
                const page = await pdf.getPage(i);
                const textContent = await page.getTextContent();
                const pageText = textContent.items.map(item => item.str).join(' ');
                // Add a double newline to simulate a page break, which helps the recursive chunker
                fullText += pageText + '\n\n';
            }
            return fullText.trim();
        }
        async function parseDocxToText(file) {
            const arrayBuffer = await file.arrayBuffer();
            const result = await mammoth.extractRawText({ arrayBuffer });
            return result.value.trim();
        }
        function recursiveChunkText(text, options = {}) {
            const { chunkSize = 2000, separators = ['\n\n', '\n', ' ', ''] } = options;

            const finalChunks = [];

            // Start with the full text as the first chunk to process
            let chunksToProcess = [text];

            // Loop through separators from largest to smallest
            for (const separator of separators) {
                const nextChunksToProcess = [];
                for (const chunk of chunksToProcess) {
                    if (chunk.length <= chunkSize) {
                        // If the chunk is already small enough, add it to the final list
                        finalChunks.push(chunk);
                    } else {
                        // If the chunk is too large, split it with the current separator
                        const subChunks = chunk.split(separator);
                        for (const subChunk of subChunks) {
                            if (subChunk.trim() !== '') {
                                // Add these smaller pieces to be processed by the next separator
                                nextChunksToProcess.push(subChunk);
                            }
                        }
                    }
                }
                // The smaller pieces become the input for the next loop iteration
                chunksToProcess = nextChunksToProcess;
            }
            // Any remaining chunks (those that couldn't be split further) are added
            finalChunks.push(...chunksToProcess.filter(c => c.trim() !== ''));
            return finalChunks;
        }
    </script>
</body>

</html>